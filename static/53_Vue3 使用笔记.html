<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/css/code-style.css">
    <link rel="stylesheet" href="/css/page.css"> <link rel="stylesheet" href="/css/animate.css/4.1.1/animate.min.css">
    <title>Vue3 使用笔记</title>
</head>

<body>
    <script type='text/javascript' src='//unpkg.com/vue@3.0.11/dist/vue.global.js'> </script>
    <div class="content"><div class='more-block'><details><summary>目录导航</summary>
<p><div class="toc-block"><ul><li><a href="#API">API</a></li><ul><li><a href="#全局API">全局API</a></li><li><a href="#应用API">应用API</a></li><li><a href="#组合式API">组合式API</a></li><li><a href="#响应式API">响应式API</a></li></ul><li><a href="#方法">方法</a></li><ul><li><a href="#实例方法">实例方法</a></li><ul><li><a href="#$watch">$watch</a></li><li><a href="#$emit">$emit</a></li><li><a href="#$forceUpdate">$forceUpdate</a></li><li><a href="#$nextTick">$nextTick</a></li></ul></ul><li><a href="#指令">指令</a></li><ul><li><a href="#常用指令">常用指令</a></li><li><a href="#特殊指令">特殊指令</a></li><ul><li><a href="#key : number | string">key : number | string</a></li><li><a href="#ref : string | Function">ref : string | Function</a></li><li><a href="#is : string | Object (component’s options object)">is : string | Object (component’s options object)</a></li></ul></ul><li><a href="#组件">组件</a></li><ul><li><a href="#内置组件">内置组件</a></li><ul><li><a href="#Teleport">Teleport</a></li></ul></ul></ul></div></p>
</details></div><h1><a id="API"></a>API</h1>
<h2><a id="全局API"></a>全局API</h2>
<h2><a id="应用API"></a>应用API</h2>
<h2><a id="组合式API"></a>组合式API</h2>
<h2><a id="响应式API"></a>响应式API</h2>
<hr />
<h1><a id="方法"></a>方法</h1>
<h2><a id="实例方法"></a>实例方法</h2>
<h3><a id="$watch"></a>$watch</h3>
<div class='more-block'><details><summary>参数：</summary>
<ul>
<li>source：string | Function</li>
<li>callback：Function | Object</li>
<li>[options]：Object</li>
<li>
<ul>
<li>deep：boolean</li>
</ul>
</li>
<li>
<ul>
<li>immediate：boolean</li>
</ul>
</li>
<li>
<ul>
<li>flush：string</li>
</ul>
</li>
</ul>
<p>返回：</p>
<ul>
<li>{Function} unwatch  取消侦听函数，用来停止触发回调</li>
</ul>
</details></div><p>参考 <a href="https://v3.cn.vuejs.org/api/instance-methods.html#watch" target="_blank">$watch</a>、<a href="https://v3.cn.vuejs.org/guide/computed.html#%E4%BE%A6%E5%90%AC%E5%99%A8" target="_blank">Watchers</a>、</p>
<p>侦听组件实例上的响应式 property 或函数计算结果的变化。回调函数得到的参数为新值和旧值。我们只能将顶层的 <code>data</code>、<code>prop</code>或<code>computed</code>property 名作为字符串传递。对于更复杂的表达式，用一个函数取代。</p>
<p>当侦听的值是一个对象或者数组时，对其属性或元素的任何更改都不会触发侦听器，因为它们引用相同的对象/数组：</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">const</span> app = Vue.createApp({
  data() {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">article</span>: {
        <span class="hljs-attr">text</span>: <span class="hljs-string">'Vue is awesome!'</span>
      },
      <span class="hljs-attr">comments</span>: [<span class="hljs-string">'Indeed!'</span>, <span class="hljs-string">'I agree'</span>]
    }
  },
  created() {
    <span class="hljs-keyword">this</span>.$watch(<span class="hljs-string">'article'</span>, () =&gt; {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Article changed!'</span>)
    })

    <span class="hljs-keyword">this</span>.$watch(<span class="hljs-string">'comments'</span>, () =&gt; {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Comments changed!'</span>)
    })
  },
  <span class="hljs-attr">methods</span>: {
    <span class="hljs-comment">// 这些方法不会触发侦听器，因为我们只更改了Object/Array的一个property，</span>
    <span class="hljs-comment">// 不是对象/数组本身</span>
    changeArticleText() {
      <span class="hljs-keyword">this</span>.article.text = <span class="hljs-string">'Vue 3 is awesome'</span>
    },
    addComment() {
      <span class="hljs-keyword">this</span>.comments.push(<span class="hljs-string">'New comment'</span>)
    },

    <span class="hljs-comment">// 这些方法将触发侦听器，因为我们完全替换了对象/数组</span>
    changeWholeArticle() {
      <span class="hljs-keyword">this</span>.article = { <span class="hljs-attr">text</span>: <span class="hljs-string">'Vue 3 is awesome'</span> }
    },
    clearComments() {
      <span class="hljs-keyword">this</span>.comments = []
    }
  }
}).mount(<span class="hljs-string">'#app'</span>)

<span class="hljs-keyword">const</span> unwatch = vm.$watch(<span class="hljs-string">'a'</span>, cb)
<span class="hljs-comment">// 停掉观察者</span>
unwatch()
</code></div></pre>
<p><em><strong>option.deep</strong></em><br />
为了发现对象内部值的变化，可以在选项参数中指定 deep: true。这个选项同样适用于监听数组变更。</p>
<div class='tip-block warning'><span class='title'> 注意: </span><p>当变更(不是替换)对象或数组并使用 deep 选项时，<strong>旧值</strong>将与<strong>新值</strong>相同，因为它们的引用指向同一个对象/数组。Vue 不会保留变更之前值的副本。</p>
</div><p><em><strong>option.immediate</strong></em><br />
在参数中指定<code>immediate: true</code>将立即以表达式当前的值来触发回调：</p>
<pre><div class="hljs"><code class="lang-js">vm.$watch(<span class="hljs-string">'a'</span>, callback, {
  <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span>
})
<span class="hljs-comment">// 立即以 `a` 的当前值触发 `callback`</span>
</code></div></pre>
<div class='tip-block warning'><span class='title'> 注意： </span><p>在带有<code>immediate</code>选项时，你不能在第一次回调时取消侦听给定的property。</p>
<p>参考：<a href="https://v3.cn.vuejs.org/api/instance-methods.html#watch" target="_blank">$watch</a></p>
</div><p><em><strong>option. flush</strong></em><br />
<mark>flush</mark>选项可以更好地控制回调的时间。它可以设置为<code>pre</code>、<code>post</code>或<code>sync</code>。<br />
默认值是<code>pre</code>，指定的回调应该在渲染前被调用。它允许回调在模板运行前更新其他值。<br />
<code>post</code>值是可以用来将回调推迟到渲染之后的。如果回调需要通过<code>$refs</code>访问更新的DOM或子组件，那么则使用该值。<br />
如果<mark>flush</mark>被设置为<code>sync</code>，一旦值发生了变化，回调将被同步调用。<br />
对于 <code>pre</code>、<code>post</code>回调使用队列进行缓冲。回调只被添加到队列中一次，即使观察值变化了多次。值的中间变化将被跳过，不会传递给回调。</p>
<p>缓冲回调不仅可以提高性能，还有助于保证数据的一致性。在执行数据更新的代码完成之前，侦听器不会被触发。</p>
<p><code>sync</code>侦听器应少用，因为它们没有这些好处。<br />
更多关于 flush 的信息，请参阅<a href="https://v3.cn.vuejs.org/guide/reactivity-computed-watchers.html#%E5%89%AF%E4%BD%9C%E7%94%A8%E5%88%B7%E6%96%B0%E6%97%B6%E6%9C%BA" target="_blank">副作用刷新时机</a>.</p>
<h3><a id="$emit"></a>$emit</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>eventName：string</li>
<li>[…args]</li>
</ul>
</details></div><p>触发当前实例上的事件。附加参数都会传给监听器回调。</p>
<pre><div class="hljs"><code class="lang-js">app.component(<span class="hljs-string">'welcome-button'</span>, {
  <span class="hljs-attr">emits</span>: [<span class="hljs-string">'welcome'</span>],
  <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;button v-on:click="$emit('welcome')"&gt; Click me &lt;/button&gt;`</span>
})
</code></div></pre>
<div class='tip-block warning'><p>自定义事件时，建议定义所有发出的事件；参考：<a href="https://v3.cn.vuejs.org/guide/component-custom-events.html" target="_blank">自定义事件</a>、<a href="https://v3.cn.vuejs.org/guide/component-basics.html#%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E6%8A%9B%E5%87%BA%E4%B8%80%E4%B8%AA%E5%80%BC" target="_blank">使用事件抛出一个值</a></p>
</div><h3><a id="$forceUpdate"></a>$forceUpdate</h3>
<p>迫使组件实例重新渲染。</p>
<div class='tip-block warning'><span class='title'> 注意： </span><p>它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p>
</div><h3><a id="$nextTick"></a>$nextTick</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>callback：Function</li>
</ul>
</details></div><p>将回调延迟到下次 DOM 更新循环之后执行。</p>
<div class='tip-block warning'><span class='title'> 注意： </span><p>组件内<code>nextTick</code>跟全局方法<code>nextTick</code>一样，不同的是回调的<code>this</code>自动绑定到调用它的实例上。</p>
</div><p>参考：<a href="https://v3.cn.vuejs.org/api/global-api.html#nexttick" target="_blank">nextTick</a></p>
<hr />
<h1><a id="指令"></a>指令</h1>
<div id="top"></div>
<h2><a id="常用指令"></a>常用指令</h2>
<p><a href="https://v3.cn.vuejs.org/api/directives.html#v-text" target="_blank">v-text</a><br />
<a href="https://v3.cn.vuejs.org/api/directives.html#v-html" target="_blank">v-html</a><br />
<a href="https://v3.cn.vuejs.org/api/directives.html#v-show" target="_blank">v-show</a><br />
<a href="https://v3.cn.vuejs.org/api/directives.html#v-if" target="_blank">v-if</a><br />
<a href="https://v3.cn.vuejs.org/api/directives.html#v-else" target="_blank">v-else</a><br />
<a href="https://v3.cn.vuejs.org/api/directives.html#v-else-if" target="_blank">v-else-if</a><br />
<a href="https://v3.cn.vuejs.org/api/directives.html#v-for" target="_blank">v-for</a><br />
<a href="https://v3.cn.vuejs.org/api/directives.html#v-on" target="_blank">v-on</a> （abbr:<code>@</code>）<br />
<a href="https://v3.cn.vuejs.org/api/directives.html#v-bind" target="_blank">v-bind</a> （abbr:<code>:</code>）<br />
<a href="https://v3.cn.vuejs.org/api/directives.html#v-model" target="_blank">v-model</a><br />
<a href="https://v3.cn.vuejs.org/api/directives.html#v-once" target="_blank">v-once</a><br />
<a href="https://v3.cn.vuejs.org/api/directives.html#v-is" target="_blank">v-is</a></p>
<p><strong><a href="https://v3.cn.vuejs.org/api/directives.html#v-slot" target="_blank">v-slot</a></strong> （abbr:<code>#</code>）<br />
可放置在函数参数位置的 JavaScript 表达式 (在支持的环境下可使用解构)。可选，即只需要在为插槽传入 prop 的时候使用。<br />
提供具名插槽或需要接收 prop 的插槽。</p>
<pre><div class="hljs"><code class="lang-js">&lt;!-- 具名插槽 --&gt;
&lt;base-layout&gt;
  &lt;template v-slot:header&gt;
    Header content
  &lt;/template&gt;

  &lt;template v-slot:default&gt;
    Default slot content
  &lt;/template&gt;

  &lt;template v-slot:footer&gt;
    Footer content
  &lt;/template&gt;
&lt;/base-layout&gt;

&lt;!-- 接收 prop 的具名插槽 --&gt;
&lt;infinite-scroll&gt;
  &lt;template v-slot:item="slotProps"&gt;
    &lt;div class="item"&gt;
      {{ slotProps.item.text }}
    &lt;/div&gt;
  &lt;/template&gt;
&lt;/infinite-scroll&gt;

&lt;!-- 接收 prop 的默认插槽，使用了解构 --&gt;
&lt;mouse-position v-slot="{ x, y }"&gt;
  Mouse position: {{ x }}, {{ y }}
&lt;/mouse-position&gt;
</code></div></pre>
<p>扩展阅读：<a href="https://v3.cn.vuejs.org/guide/component-slots.html" target="_blank">组件 - 插槽</a></p>
<p><strong><a href="https://v3.cn.vuejs.org/api/directives.html#v-pre" target="_blank">v-pre</a></strong><br />
跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。</p>
<div class='tip-block info'><p>不需要表达式；跳过大量没有指令的节点会加快编译。</p>
</div><pre><div class="hljs"><code class="lang-js">&lt;!-- 抛出错误 --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{{ this will not be compiled }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>

&lt;!-- 正常运行，不编译表达式直接显示内容 --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-pre</span>&gt;</span>{{ this will not be compiled }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>

&lt;!-- 正常运行，不编译表达式，HTML正常被浏览器解析 --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-pre</span>&gt;</span> {{ title }} <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"red"</span>&gt;</span>文字<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>@[toc]
</code></div></pre>
<p><strong><a href="https://v3.cn.vuejs.org/api/directives.html#v-cloak" target="_blank">v-cloak</a></strong><br />
cloak(英 [kləʊk]) 遮盖; 掩盖; 伪装; 幌子<br />
这个指令保持和元素实例的关联，直到关联组件实例结束被移除。</p>
<div class='tip-block info'><p>不需要表达式。</p>
</div><pre><div class="hljs"><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-cloak</span>&gt;</span>
  {{ message }}
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></div></pre>
<pre><div class="hljs"><code class="lang-css"><span class="hljs-selector-attr">[v-cloak]</span> {
  <span class="hljs-attribute">display</span>: none;
}
</code></div></pre>
<p>当网络较慢，网页还在加载 Vue.js ，而导致 Vue 来不及渲染，这时页面就会显示出 Vue 源代码<code>{{ message }}</code>。<br />
我们可以使用 v-cloak 指令来解决差值表达式闪烁的问题（即：可以隐藏未编译的标签直到实例准备完毕）。</p>
<p>例子：页面加载完成后，延迟3秒挂载vue.js，观察v-cloak修饰的组件区别</p>
<style>
[v-cloak] {
    color: red;
    opacity: 0.25;
    font-weight: bold;
    font-size: 2em;
}
</style>
<div id="example3">
    使用 v-cloak：
    <span v-cloak>{{title}}</span>
    未使用v-cloak：
    <span>{{title}}</span>
</div>
<script>
const app3 = Vue.createApp({
    data() {
        return {
            title: "helloword",
        }
    }
});

setTimeout(()=>{
  app3.mount('#example3')
}, 3000);
</script>
<h2><a id="特殊指令"></a>特殊指令</h2>
<h3><a id="key : number | string"></a>key : number | string</h3>
<p><a href="https://v3.cn.vuejs.org/api/special-attributes.html#key" target="_blank">查看文档</a></p>
<p>key 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。<br />
有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。</p>
<p>最常见的用例是结合 v-for：</p>
<pre><div class="hljs"><code class="lang-js">&lt;ul&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"item.id"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
&lt;<span class="hljs-regexp">/ul&gt;
</span></code></div></pre>
<p>它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用：</p>
<ul>
<li>完整地触发组件的生命周期钩子</li>
<li>触发过渡</li>
</ul>
<p>例如：</p>
<pre><div class="hljs"><code class="lang-js">&lt;transition&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"text"</span>&gt;</span>{{ text }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>
&lt;<span class="hljs-regexp">/transition&gt;
</span></code></div></pre>
<div class='tip-block info'><p>当 text 发生改变时，<span> 总是会被替换而不是被修改，因此会触发过渡。</p>
</div><p>例子：</p>
<h4 id="example1" class="clock">
    <transition mode="in-out" enter-active-class="animate__animated animate__flipInX" leave-active-class="animate__animated animate__flipInX">
        <span :key="time">{{time}}</span>
    </transition>
</h4>
<style>
.clock {
    display: block;
    position: relative;
    height: 50px;
    margin:0;
}

.clock span {
    display: inline-block;
    position: absolute;
    background: #fff;
    padding: 5px 20px;
}
</style>
<script>
Vue.createApp({
    data() {
        return {
            time: "00:00"
        }
    },
    created() {
        setInterval(() => {
            this.time = new Date().toLocaleString("chinese", { hour12: false });
        }, 500);
    }
}).mount('#example1');
</script>
<h3><a id="ref : string | Function"></a>ref : string | Function</h3>
<p><a href="https://v3.cn.vuejs.org/api/special-attributes.html#ref" target="_blank">查看文档</a></p>
<p><code>ref</code>被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的<code>$refs</code>对象上。如果在普通的<mark>DOM</mark>元素上使用，引用指向的就是<mark>DOM</mark>元素；如果用在子组件上，引用就指向组件实例：</p>
<pre><div class="hljs"><code class="lang-js">&lt;!-- vm.$refs.p 会是 DOM 节点 --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"p"</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>

&lt;!-- vm.$refs.child 会是子组件实例 --&gt;
&lt;child-component ref="child"&gt;&lt;/child-component&gt;

&lt;!-- 当动态绑定时，我们可以将ref定义为回调函数，显式地传递元素或组件实例 --&gt;
&lt;child-component :ref="(el) =&gt; child = el"&gt;&lt;/child-component&gt;
</code></div></pre>
<p>当 v-for 用于元素或组件的时候，引用信息将是包含 DOM 节点或组件实例的数组。</p>
<div class='tip-block warning'><span class='title'> 关于 ref 注册时间的重要说明 </span><p>因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - <strong>它们还不存在</strong>！<br />
<code>$refs</code>也是非响应式的，因此你不应该试图用它在模板中做数据绑定。</p>
</div><p>参考<a href="https://v3.cn.vuejs.org/api/special-attributes.html#key" target="_blank">子组件Refs</a></p>
<h3><a id="is : string | Object (component’s options object)"></a>is : string | Object (component’s options object)</h3>
<p><a href="https://v3.cn.vuejs.org/api/special-attributes.html#is" target="_blank">查看文档</a> 、<a href="https://v3.cn.vuejs.org/guide/component-basics.html#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6" target="_blank">动态组件基础</a>、<a href="https://v3.cn.vuejs.org/guide/component-dynamic-async.html" target="_blank">动态组件 &amp; 异步组件</a>。</p>
<p>扩展 html标签的限制, 动态切换并渲染指定的组件</p>
<h1><a id="组件"></a>组件</h1>
<h2><a id="内置组件"></a>内置组件</h2>
<h3><a id="Teleport"></a>Teleport</h3>
<p><a href="https://v3.cn.vuejs.org/guide/teleport.html" target="_blank">查看文档</a></p>
<p>Vue 鼓励我们通过将 UI 和相关行为封装到组件中来构建 UI。我们可以将它们嵌套在另一个内部，以构建一个组成应用程序 UI 的树。</p>
<ul>
<li><code>to</code> - <mark>string</mark>。需要<code>prop</code>，必须是有效的查询选择器或<code>HTMLElement</code>(如果在浏览器环境中使用)。指定将在其中移动 <code>&lt;teleport&gt;</code> 内容的目标元素</li>
</ul>
<pre><div class="hljs"><code class="lang-js">&lt;!-- 正确 --&gt;
&lt;teleport to="#some-id" /&gt;
&lt;teleport to=".some-class" /&gt;
&lt;teleport to="[data-teleport]" /&gt;

&lt;!-- 错误 --&gt;
&lt;teleport to="h1" /&gt;
&lt;teleport to="some-string" /&gt;
</code></div></pre>
<ul>
<li><code>disabled</code> - <mark>boolean</mark>。此可选属性可用于禁用 <teleport> 的功能，这意味着其插槽内容将不会移动到任何位置，而是在您在周围父组件中指定了 <code>&lt;teleport&gt;</code> 的位置渲染。</li>
</ul>
<pre><div class="hljs"><code class="lang-js">&lt;teleport to=<span class="hljs-string">"#popup"</span> :disabled=<span class="hljs-string">"displayVideoInline"</span>&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./my-movie.mp4"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">teleport</span>&gt;</span></span>
</code></div></pre>
<div class='tip-block warning'><p>请注意，将移动实际的 DOM 节点，而不是被销毁和重新创建，并且它还将保持任何组件实例的活动状态。所有有状态的 HTML 元素 (即播放的视频) 都将保持其状态。</p>
</div><p>例子：</p>
<style>
.video-item {
    position: relative;
    width: 240px;
    height: 135px;
    display: inline-block;
    margin-top: 5px;
    margin-left: 5px;
    background: #eee;
}

.video-item video {
    padding: 0;
    margin: 0;
}

.video-item::before {
    content: 'come here';
    color: #bababa;
    width: 100%;
    display: block;
    text-align: center;
    position: absolute;
}
</style>
<div id="example2">
    <div id="seat" class="video-item" @click.self="goHandler"> </div>
    <div class="video-item" @click.self="goHandler"></div>
    <teleport :to="target">
        <video src="/assets/medias/Piper_720P.mp4" class="video-item" controls loop webkit-playsinline="webkit-playsinline" playsinline="playsinline"></video>
    </teleport>
    <div class="video-item" @click.self="goHandler"></div>
    <div class="video-item" @click.self="goHandler"></div>
    <div>
        <button @click="moveHandler('body')">移动到body</button>
        <button @click="moveHandler('#top')">移动到顶部</button>
        <button @click="moveHandler('#example1')">移动到中间</button>
        <button @click="moveHandler('.content')">移动到底部</button>
        <small>video在移动后播放状态不会暂停</small>
    </div>
</div>
<script>
Vue.createApp({
    data() {
        return {
            target: "#seat",
        }
    },
    methods: {
        goHandler(event) {
          this.moveHandler(event.target);
        },
        moveHandler(el) {
          this.target = el;
        },
    }
}).mount('#example2');
</script>
</div>
</body>
<script src="/js/prism.js"></script>
<script>
    window.onload = function() {
        window.Prism = window.Prism || {};
        window.Prism.manual = true;
    }
</script>

</html>